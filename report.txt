CSE 20211 Final Project Report - Steven Mike

From the user’s perspective, the user can enter w, a, s, d, or space to perform actions. The user is represented by a blue circle and can move up with w, down with s, left with a, and right with d, and can shoot with space. The user is trying to shoot red squares (and one purple one) while avoiding the lasers they shoot. The user can see their score and lives at the top. Once the game is over, the user can see the command window for outputs, and may be prompted to input his or her initials.

The program begins with the preprocessors, some #define statements for the window size, a struct declaration of goodLaser (typedeffed for goodLaserType) and has 3 ints, xpos, ypos, and dmg, a double, speed, and a pointer to another struct of the same type. Next are the function prototypes. The main method begins with all the variables. The program then opens a gfx window, sets some values in arrays to 0, and calls the createEnemies function before starting the while loop. The while loop can be exited if the user inputs p at all. The while loop starts by clearing the window with gfx_clear, and then calls the movement function and the drawChar function. Then the program determines if the user has entered space or not, and if the user has then a link list is created if it doesn’t already exist, or a struct of the goodLaserType is added on. An int shotsFired is also incremented to keep track of the total number of goodLasers. The function then calls drawGoodLasers to draw the good lasers. The program then either calls drawEnemies or the boss function depending on whether or not the boss is ready to come out yet. The program then updates the enemies’ positions, and health with the updateEnemies function. The program also will also get rid of lasers that have already hit an enemy. The program then creates and draws the enemy lasers with the enemyLasers and drawEnemyLasers functions. The program then uses a Boolean to tell if the character is invincible and if the int is 1, a “timer” is used to set it to 0, and if it is 0 then the hit function is called. Next, the callWave function is called to determine which enemies should be present. Then the displayScore and displayLives functions are called before gfx_flush is called. Then there is a call to usleep, certain variables are incremented, and the loop exits if the game is over. This concludes the while loop, and then gameOver is called before the function terminates. All the functions are void except for the hit function and the updateEnemies function. The movement function takes the array of which buttons are pushed, pointers to the characters position, and updates the characters position. The drawChar function takes the position and draws the character. The drawGoodLasers takes the start of the linked list and another struct p, and draws all the lasers in the list. Lasers outside of a specific location are taken from the list and put into a two-D array and head is updated using a pointer to the struct. The drawEnemies function takes the arrays of enemies and draws them based on their position. The updateEnemies function takes the array of enemies, the linked list, and various pointers, to lower the enemy health if they are hit by a laser, and update the score and dmg of the laser, which doubles with each enemy kill. It also updates the enemy position. The displayScore function takes a string, the score and the number of fired shots, and displays a recalculated score. The displayLives function display the numbers of lives left and takes the string and lives as the input. The createEnemies function just takes the arrays of enemies, and sets up all of their values for when they are used. It is a 2D array, and the 4th position of each enemy is set to 1 when they are on-screen and 0 when they are off. The callWave function takes the enemies and an int dead, and when dead reaches certain numbers, the next wave of enemies will appear. The boss function is the same as the drawEnemy function but it draws it purple instead of red. The drawEnemy function takes the array of enemies, as does the boss function, and draws them as red squares if they are supposed to appear. The enemyLasers functions takes in the array of enemies, the two arrays of enemy lasers, and a pointer to time and dead, and shoots 5 lasers per enemy out after certain amounts of time. The boss shoots twice as fast and twice as often. The drawEnemyLasers functions takes the enemies and their arrays of lasers, and draws them as well as updating the positioning using simple trigonometry. The lasers at 27 0 degrees had to manually be put in because 270 degrees was not going straight downward. The hit function takes the lives, the characters positions, the arrays with enemy lasers, and the score, and if a laser is on the character, the character loses a life and the score drops. It returns an int to determine if the character was hit or not. Finally, the gameOver function takes the score, the lives, and the shots fired. It calculates the final score, tells the user the highscore and whether they won or lost. If their score was greater than the highscore, which is in a textfile, the user is prompted to enter their 3 initials and the textfile is overwritten with their initials and score using filepointers. This concludes the main program. The gfx3 was slightly altered to allow for multiple inputs by checking when buttons were released also and using an array to determine which keys are pressed and released at each call to gfx_wait.

I verified the output was correct by testing each function individually. Once I verified that a function did what I required it to do, I was able to move on to the next function and assume it would work once placed in conjunction with the other functions, although there was very little interaction between the functions in this lab. I also checked to make sure that the program properly created the operated properly with hits and the score and various other parameters and did what I wanted.

